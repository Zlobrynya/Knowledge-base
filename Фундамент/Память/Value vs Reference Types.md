В Swift все типы делятся на две основные группы по способу передачи и хранения в памяти: **value types** (типы-значения) и **reference types** (ссылочные типы). Это разделение определяет их поведение при присваивании, передаче в функции и изменении.
## Value Types

##### Суть: 
При присваивании или передаче в функцию **создается новая копия** данных. Изменение одной копии не затрагивает все остальные.
##### Поведение:
- **Семантика копирования:** Переменные хранят независимые копии данных.
- **Изменяемость:** Ключевое слово `let` делает всю переменную неизменяемой. Для изменения свойств переменная должна быть объявлена с `var`.
- **Механизм оптимизации (Copy-on-Write):** Для эффективной работы с большими данными (как `String` или `Array`) система не создает физическую копию сразу. Настоящее копирование происходит только в момент модификации. Это позволяет экономить память и ресурсы.
##### Типы:
- struct
- enum
- primitive types
- `Array`, `String`, `Set`, `Dictionary`
- Кортежи (`tuples`)
##### Где хранятся?
Хотя семантика предполагает хранение в стеке, компилятор Swift оптимизирует размещение. Value type может быть размещена в куче, если их размер нельзя расчитать. Однако это не меняет её поведения — она продолжает вести себя как независимая копия.
Такие value которые будут хранится в куче:
- Объект является частью reference type (класса). Поскольку сам класс живет в куче, все его свойства тоже находятся там.
- Рекурсивный enum
- Array, String, Set, Dictionary
- Произошел захват замыканием
- struct/primitive упакован в Array тип
##### Преимущества:
- **Предсказуемость:** Изменения в одной части кода не ломают другую.
- **Потокобезопасность:** Отсутствие разделяемого состояния упрощает многопоточность.
- **Скорость:** Размещение в стеке (где это возможно) очень быстрое.
- **Простота:** Нету необходимости использовать ARC
##### Недостатки:
- **Потенциальные накладные расходы:** Частое копирование больших структур может быть дорогим (но это mitigated by CoW).
- КУЧА (дополнить)
## Reference Types

##### Суть
При присваивании или передаче в функцию копируется **ссылка** на один и тот же существующий объект в памяти. Изменения, сделанные через одну ссылку, видны через все остальные.
##### Поведение:
- **Семантика ссылки:** Переменные хранят ссылку на общий объект.    
- **Изменяемость:** `let` запрещает изменение самой ссылки (нельзя присвоить новый объект), но свойства изменяемого объекта (`var`) менять можно.
- **Управление памятью:** Память в куче управляется автоматически через **Automatic Reference Counting (ARC)**.
##### Типы:
- Class
- Actor
- Closures (замыкания)
##### Где хранятся?
Всегда в куче. Но компилятор может произвести оптимизацию и запихать класс в стек - это оптимизация называется **Stack Promotion** (или Escape Analysis)
Условия для этого:
- Объект является локальным - создается внутри scope и не поставляются "наружу".
	- Объект не создает доп сильных ссылок.
	- Объект не передается во внешние структуры/функции.
	- Объект не захватывается.
	- Объект не сохранятся в свойствах другого "убегающего" объекта.
- Размер объекта и его поведение известны на этапе компиляции.
##### Преимущества:
- Полиморфизм/наследование
- Единый объект (синхронизация, общее использование, эффективность памяти)
- Управление жизненным циклом
##### Недостатки:
- Возникают проблемы многопоточности 
- ARC и утечки памяти 
- Накладные расходы на выделение памяти
- Копирование требует доп работы 
## Copy-on-Write (CoW)

Механизм в Swift, который позволяет оптимизировать использование памяти для больших value типов - `Array`, `String`, `Set`, `Dictionary`
##### Суть
Все эти типы создаются в куче и в стеке просто хранится ссылка на объект. При передаче из scope в другой scope, передается ссылка на объект, а не происходит полное коппирование как других value-type. Копирование происходит только при изменении типа, тогда в куче выделяется новая область памяти и копируется весь объект.
##### Реализация

```swift
struct CowWrapper<T> {
    private var _storage: Box<T>
    
    private final class Box<Value> {
        var value: Value
        init(_ value: Value) { 
	        self.value = value
        }
    }
    
    init(_ value: T) {
        _storage = Box(value)
    }
    
    var value: T {
        get { 
	        _storage.value 
	    }
        set {
            if !isKnownUniquelyReferenced(&_storage) {
                _storage = Box(newValue)
            } else {
                _storage.value = newValue
            }
        }
    }
    
    mutating func mutate(_ transformation: (inout T) -> Void) {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = Box(_storage.value)
        }
        transformation(&_storage.value)
    }
}
```

**isKnownUniquelyReferenced** - это функция стандартной библиотеки Swift, которая проверяет, является ли ссылка уникальной.
## inout

`inout` — это ключевое слово в Swift, которое позволяет функции изменять значение переданного параметра, сохраняя эти изменения после завершения работы функции. Это способ реализации "сквозной передачи параметров по ссылке".
##### Как работает `inout`?

1. **Передача значения**: При вызове функции с `inout`-параметром передается не сама переменная, а её временная копия.
2. **Изменение внутри функции**: Функция работает с этой временной копией.
3. **Обратное копирование**: После завершения функции измененное значение копируется обратно в исходную переменную.

Этот процесс формально называется "copy-in copy-out" или "call by value result".
##### Ограничения и особенности

1. **Только для переменных**: Нельзя передать константу (`let`) или литерал
2. **Явное указание**: При вызове обязательно использовать `&`
3. **Не для вычисляемых свойств**: Можно использовать только с хранимыми свойствами
4. **Замыкания**: Если `inout`-параметр захватывается замыканием, это создает отдельную копию
5. **CoW**: Для массивов с CoW механизм `inout` может привести к немедленному срабатыванию Copy-on-Write, если выполнятся условия срабатывания.