## Cooperative Thread Pool

Это низкоуровневый механизм управление асинхронными задачами, суть которого состоит в том, что бы создать столько Thread сколько ядер на устройстве и оперировать ими. В отличия от GCD, это позволяет сократить накладные расходы на создание Thread и позволяет избежать проблемы thread explosion, так как у нас ограниченное число thread.
Ниже показан принцип работы:

![[Pasted image 20250821213913.png]]

Из него видно, что async/await подставляет в текущие thread, задачи которые начинают выполнять. Задача выполняется до следующей точки остановки **await**, тем самым освобождая поток и давая другой задачи место для ее выполнения.

Async/await напрямую не работает с Cooperative Thread Pool, она делает это через абстракции называемые Executors
## Executors 

Executors - это сервисы которые принимают и передают задачи (Job) на выполнение в нижестоящий Cooperative Thread Pool, другими словами это "системный планировщик". 
В swift предустановлены следующие executors: 
1. Global concurrent executor - планировщик по умолчанию, является парралельным (конкурентным) и распределяет Job по потокам в Cooperative Thread Pool.
2. Serial executors - последовательный планировщик,[[Actors]] базируется на нем. Данный Executor является последовательным. У каждого actor, он свой.
3. Main Actor executor — особый serial executor, который выполняет джобы на main thread.

Для обычного продакшен кода, вам хватит выше стоящих executors с головой, но если возникает специфичная потребность управлять JOB или добавить Actor возможность выполнять 2 Job параллельно (правда зачем?), вам в этом помогут следующие два протокола: 
1. [SerialExecutor](https://developer.apple.com/documentation/swift/serialexecutor) - позволяет прописать свой executor для акторов. 
2. [TaskExecutor](https://developer.apple.com/documentation/swift/taskexecutor) - позволяет прописать свой executor для выполенении Jobs в Task.

### Разберемся с протоколом [SerialExecutor](https://developer.apple.com/documentation/swift/serialexecutor) 
```swift 
public protocol SerialExecutor : Executor {
	/// Метод в которую прилетает Job, которую нам следует обработать.
    func enqueue(_ job: consuming ExecutorJob)

	/// Возвращает безхозную (unowned) ссылку на executor.
    func asUnownedSerialExecutor() -> UnownedSerialExecutor
}
```
Как видно из протокола, нам следует описать два обязательных метода, первый метод в которому будет реализована обработка пришедшей к нам Job, а второй метод необходим для создания слабой (в данном случае unowned) ссылки, что б ARC корректно обрабатывал executor. 

```swift
final class MySerialExecutor: SerialExecutor {

    // 2. Приватная очередь для последовательного выполнения задач.
    private let queue: DispatchQueue

    init(label: String) {
        self.queue = DispatchQueue(label: label)
    }

    func enqueue(_ job: consuming ExecutorJob) {
        // Создаем Job безопастную для захвата в ссылки.
        let unownedJob = UnownedJob(job)
        // Создаем наш Executor безопасный для захвата в ссылки.
        let unownedExecutor = asUnownedSerialExecutor()
        
        queue.async {
	        // Начинаем синхронное выполенение job на нашей очереди.
            unownedJob.runSynchronously(on: unownedExecutor)
        }
    }

    func asUnownedSerialExecutor() -> UnownedSerialExecutor {
	    // Специальная обертка для создание безхозной ссылки.
        UnownedSerialExecutor(ordinary: self)
    }
}```

После того как мы определили наш свой executor, мы можем его начать использовать в actor. Более подробнее каким образом добавляется executor, в акторы, смотри в разделе [[Actors]].

### Разберемся с протоколом [TaskExecutor](https://developer.apple.com/documentation/swift/taskexecutor)

Начиная с **ios 18**, у Task появилось следующее API

```swift
@discardableResult
Task(
    name: String? = nil,
    executorPreference taskExecutor: (any TaskExecutor)?,
    priority: TaskPriority? = nil,
    operation: sending @escaping () async throws -> Success
)
```
Нас в данном случае интересует поле: "executorPreference taskExecutor: (any TaskExecutor)?" - Оно позволяет нам добавить свой собственный executor, который будет управлять выполнением Job, которые создадуться в этой Task.

Протокол TaskExecutor, повторяет ранее разобранный SerialExecutor
```swift
protocol TaskExecutor : Executor {
	/// Метод в которую прилетает Job, которую нам следует обработать.
    func enqueue(_ job: consuming ExecutorJob)
    /// Возвращает безхозную (unowned) ссылку на executor.
    func asUnownedTaskExecutor() -> UnownedTaskExecutor
}
```

Например, мы хотим, что бы Task которые выполняются на нашем CustomExecutor, выполнялись последовательно, поэтому реализуем следующий класс
```swift
@available(iOS 18.0, *)
final class CustomExecutor: TaskExecutor {
    private let queue: DispatchQueue

    init(label: String) {
        self.queue = DispatchQueue(label: label)
    }

    func enqueue(_ job: consuming ExecutorJob) {
        let unownedJob = UnownedJob(job)
        let unownedExecutor = asUnownedTaskExecutor()

        queue.async {
            unownedJob.runSynchronously(on: unownedExecutor)
        }
    }

    func asUnownedTaskExecutor() -> UnownedTaskExecutor {
        UnownedTaskExecutor(ordinary: self)
    }
}
```

```swift
let customExecutor = CustomExecutor(label: "Test")
// Создаем detached task с предпочтением нашего кастомного исполнителя
Task.detached(executorPreference: customExecutor) {
    print("Работа задачи начинается на потоке: \(Thread.current) 1 ")
    try? await Task.sleep(nanoseconds: 100)
    print("Работа задачи продолжается на потоке: \(Thread.current) 2 ")
}
Task.detached(executorPreference: customExecutor) {
    print("Работа задачи начинается на потоке: \(Thread.current) 3 ")
    try? await Task.sleep(nanoseconds: 100)
    print("Работа задачи продолжается на потоке: \(Thread.current) 4")
}
```
В итоге мы получим следующий ввывод в консоль
```
Работа задачи начинается на потоке: <NSThread: 0x60000170d100> 1 
Работа задачи продолжается на потоке: <NSThread: 0x60000170d100> 2 
Работа задачи начинается на потоке: <NSThread: 0x60000171b180> 3 
Работа задачи продолжается на потоке: <NSThread: 0x600001724040> 4
```
## Job

Это часть таски, набор кода между прерываниями в Task. Если помотреть на открытие методы Job, там можно увидеть слудующее
```swift
/// A unit of schedulable work.
///
/// Unless you're implementing a scheduler,
/// you don't generally interact with jobs directly.
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen public struct ExecutorJob : Sendable, ~Copyable {

    public init(_ job: UnownedJob)

    public init(_ job: Job)

    public var priority: JobPriority { get }

    public var description: String { get }
}


@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension ExecutorJob {

    /// Run this job on the passed in executor.
    ///
    /// This operation runs the job on the calling thread and *blocks* until the job completes.
    /// The intended use of this method is for an executor to determine when and where it
    /// wants to run the job and then call this method on it.
    ///
    /// The passed in executor reference is used to establish the executor context for the job,
    /// and should be the same executor as the one semantically calling the `runSynchronously` method.
    ///
    /// This operation consumes the job, preventing it accidental use after it has been run.
    ///
    /// Converting a `ExecutorJob` to an ``UnownedJob`` and invoking ``UnownedJob/runSynchronously(_:)` on it multiple times is undefined behavior,
    /// as a job can only ever be run once, and must not be accessed after it has been run.
    ///
    /// - Parameter executor: the executor this job will be semantically running on.
    @inlinable public func runSynchronously(on executor: UnownedSerialExecutor)
    
	...   
}```

Как видно, Job состоит из собственного описания, приоритета и метода для его выполнения.
При выводе description мы получит похожий принт
```swift
ExecutorJob(id: 1)
```
Где id - номер для внутренней индентификации, причем этот id не меняется в пределах Task, неважно сколько было остановок, создается Task -> создается Job (личное наблюдение на тестовом коде)
Далее у нас есть приоритет, тут все понятно, чем выше приоритет, тем выше она будет в очереди на выполнение.
Ну и сам метод вызова выполнение кода `runSynchronously`, этот самый метод и выполняет код между остановками (await) и для его выполнения он ожидает ослабленную ссылку на текущий executor.
## Task


-

--
https://wwdcnotes.com/documentation/wwdcnotes/wwdc21-10254-swift-concurrency-behind-the-scenes/
https://habr.com/ru/articles/887240/
https://habr.com/ru/companies/otus/articles/588540/
https://colinchswift.github.io/2023-09-18/10-48-35-840309-best-practices-for-thread-pool-management-in-swift-multithreading/
https://jackmorris.xyz/posts/2023/11/21/controlling-actors-with-custom-executors/
https://habr.com/ru/companies/cleverpumpkin/articles/790782/