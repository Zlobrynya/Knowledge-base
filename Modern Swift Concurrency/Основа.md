## Cooperative Thread Pool

Это низкоуровневый механизм управление асинхронными задачами, суть которого состоит в том, что бы создать столько Thread сколько ядер на устройстве и оперировать ими. В отличия от GCD, это позволяет сократить накладные расходы на создание Thread и позволяет избежать проблемы thread explosion, так как у нас ограниченное число thread.
Ниже показан принцип работы:

![[Pasted image 20250821213913.png]]

Из него видно, что async/await подставляет в текущие thread, задачи которые начинают выполнять. Задача выполняется до следующей точки остановки **await**, тем самым освобождая поток и давая другой задачи место для ее выполнения.

Async/await напрямую не работает с Cooperative Thread Pool, она делает это через абстракции называемые Executors
## Executors 

Executors - это сервисы которые принимают и передают задачи (Job) на выполнение в нижестоящий Cooperative Thread Pool, другими словами это "системный планировщик". 
В swift предустановлены следующие executors: 
1. Global concurrent executor - планировщик по умолчанию, является парралельным (конкурентным) и распределяет Job по потокам в Cooperative Thread Pool.
2. Serial executors - последовательный планировщик,[[Actors]] базируется на нем. Данный Executor является последовательным. У каждого actor, он свой.
3. Main Actor executor — особый serial executor, который выполняет джобы на main thread.

Для обычного продакшен кода, вам хватит выше стоящих executors с головой, но если возникает специфичная потребность управлять JOB или добавить Actor возможность выполнять 2 Job параллельно (правда зачем?), вам в этом помогут следующие два протокола: 
1. [SerialExecutor](https://developer.apple.com/documentation/swift/serialexecutor) - позволяет прописать свой executor для акторов. 
2. [TaskExecutor](https://developer.apple.com/documentation/swift/taskexecutor) - позволяет прописать свой executor для выполенении Jobs в Task.

### Разберемся с протоколом [SerialExecutor](https://developer.apple.com/documentation/swift/serialexecutor) 
```swift 
public protocol SerialExecutor : Executor {
	/// Метод в которую прилетает Job, которую нам следует обработать.
    func enqueue(_ job: consuming ExecutorJob)

	/// Возвращает безхозную (unowned) ссылку на executor.
    func asUnownedSerialExecutor() -> UnownedSerialExecutor
}
```
Как видно из протокола, нам следует описать два обязательных метода, первый метод в которому будет реализована обработка пришедшей к нам Job, а второй метод необходим для создания слабой (в данном случае unowned) ссылки, что б ARC корректно обрабатывал executor. 

```swift
final class MySerialExecutor: SerialExecutor {

    // 2. Приватная очередь для последовательного выполнения задач.
    private let queue: DispatchQueue

    init(label: String) {
        self.queue = DispatchQueue(label: label)
    }

    func enqueue(_ job: consuming ExecutorJob) {
        // Создаем Job безопастную для захвата в ссылки.
        let unownedJob = UnownedJob(job)
        // Создаем наш Executor безопасный для захвата в ссылки.
        let unownedExecutor = asUnownedSerialExecutor()
        
        queue.async {
	        // Начинаем синхронное выполенение job на нашей очереди.
            unownedJob.runSynchronously(on: unownedExecutor)
        }
    }

    func asUnownedSerialExecutor() -> UnownedSerialExecutor {
	    // Специальная обертка для создание безхозной ссылки.
        UnownedSerialExecutor(ordinary: self)
    }
}```

После того как мы определили наш свой executor, мы можем его начать использовать в actor. Более подробнее каким образом добавляется executor, в акторы, смотри в разделе [[Actors]].

### Разберемся с протоколом [TaskExecutor](https://developer.apple.com/documentation/swift/taskexecutor)

Начиная с **ios 18**, у Task появилось следующее API

```swift
@discardableResult
Task(
    name: String? = nil,
    executorPreference taskExecutor: (any TaskExecutor)?,
    priority: TaskPriority? = nil,
    operation: sending @escaping () async throws -> Success
)
```
Нас в данном случае интересует поле: "executorPreference taskExecutor: (any TaskExecutor)?" - Оно позволяет нам добавить свой собственный executor, который будет управлять выполнением Job, которые создадуться в этой Task.

Протокол TaskExecutor, повторяет ранее разобранный SerialExecutor
```swift
protocol TaskExecutor : Executor {
	/// Метод в которую прилетает Job, которую нам следует обработать.
    func enqueue(_ job: consuming ExecutorJob)
    /// Возвращает безхозную (unowned) ссылку на executor.
    func asUnownedTaskExecutor() -> UnownedTaskExecutor
}
```

Например, мы хотим, что бы Task которые выполняются на нашем CustomExecutor, выполнялись последовательно, поэтому реализуем следующий класс
```swift
@available(iOS 18.0, *)
final class CustomExecutor: TaskExecutor {
    private let queue: DispatchQueue

    init(label: String) {
        self.queue = DispatchQueue(label: label)
    }

    func enqueue(_ job: consuming ExecutorJob) {
        let unownedJob = UnownedJob(job)
        let unownedExecutor = asUnownedTaskExecutor()

        queue.async {
            unownedJob.runSynchronously(on: unownedExecutor)
        }
    }

    func asUnownedTaskExecutor() -> UnownedTaskExecutor {
        UnownedTaskExecutor(ordinary: self)
    }
}
```

```swift
let customExecutor = CustomExecutor(label: "Test")
// Создаем detached task с предпочтением нашего кастомного исполнителя
Task.detached(executorPreference: customExecutor) {
    print("Работа задачи начинается на потоке: \(Thread.current) 1 ")
    try? await Task.sleep(nanoseconds: 100)
    print("Работа задачи продолжается на потоке: \(Thread.current) 2 ")
}
Task.detached(executorPreference: customExecutor) {
    print("Работа задачи начинается на потоке: \(Thread.current) 3 ")
    try? await Task.sleep(nanoseconds: 100)
    print("Работа задачи продолжается на потоке: \(Thread.current) 4")
}
```
В итоге мы получим следующий ввывод в консоль
```
Работа задачи начинается на потоке: <NSThread: 0x60000170d100> 1 
Работа задачи продолжается на потоке: <NSThread: 0x60000170d100> 2 
Работа задачи начинается на потоке: <NSThread: 0x60000171b180> 3 
Работа задачи продолжается на потоке: <NSThread: 0x600001724040> 4
```

## Job

-
## Task

-

--
https://wwdcnotes.com/documentation/wwdcnotes/wwdc21-10254-swift-concurrency-behind-the-scenes/
https://habr.com/ru/articles/887240/
https://habr.com/ru/companies/otus/articles/588540/
https://colinchswift.github.io/2023-09-18/10-48-35-840309-best-practices-for-thread-pool-management-in-swift-multithreading/
https://jackmorris.xyz/posts/2023/11/21/controlling-actors-with-custom-executors/
https://habr.com/ru/companies/cleverpumpkin/articles/790782/