## Cooperative Thread Pool

Это низкоуровневый механизм управление асинхронными задачами, суть которого состоит в том, что бы создать столько Thread сколько ядер на устройстве и оперировать ими. В отличия от GCD, это позволяет сократить накладные расходы на создание Thread и позволяет избежать проблемы thread explosion, так как у нас ограниченное число thread.
Ниже показан принцип работы:

![[Pasted image 20250821213913.png]]

Из него видно, что async/await подставляет в текущие thread, задачи которые начинают выполнять. Задача выполняется до следующей точки остановки **await**, тем самым освобождая поток и давая другой задачи место для ее выполнения.
Async/await напрямую не работает с Cooperative Thread Pool, она делает это через абстракции называемые Executors
Не смотря на преимущества такого подхода, как видно выше может образоваться проблема, когда задача слишком большая и без промежуточных точек остановок, то она полностью забивает собой один поток. 
## Executors 

Executors - это сервисы которые принимают и передают задачи (Job) на выполнение в нижестоящий Cooperative Thread Pool, другими словами это "системный планировщик". 
В swift предустановлены следующие executors: 
1. Global concurrent executor - планировщик по умолчанию, является парралельным (конкурентным) и распределяет Job по потокам в Cooperative Thread Pool.
2. Serial executors - последовательный планировщик,[[Actors]] базируется на нем. Данный Executor является последовательным. У каждого actor, он свой.
3. Main Actor executor — особый serial executor, который выполняет джобы на main thread.

Для обычного продакшен кода, вам хватит выше стоящих executors с головой, но если возникает специфичная потребность управлять JOB или добавить Actor возможность выполнять 2 Job параллельно (правда зачем?), вам в этом помогут следующие два протокола: 
1. [SerialExecutor](https://developer.apple.com/documentation/swift/serialexecutor) - позволяет прописать свой executor для акторов. 
2. [TaskExecutor](https://developer.apple.com/documentation/swift/taskexecutor) - позволяет прописать свой executor для выполенении Jobs в Task.

### Разберемся с протоколом [SerialExecutor](https://developer.apple.com/documentation/swift/serialexecutor) 
```swift 
public protocol SerialExecutor : Executor {
	/// Метод в которую прилетает Job, которую нам следует обработать.
    func enqueue(_ job: consuming ExecutorJob)

	/// Возвращает безхозную (unowned) ссылку на executor.
    func asUnownedSerialExecutor() -> UnownedSerialExecutor
}
```
Как видно из протокола, нам следует описать два обязательных метода, первый метод в которому будет реализована обработка пришедшей к нам Job, а второй метод необходим для создания слабой (в данном случае unowned) ссылки, что б ARC корректно обрабатывал executor. 

```swift
final class MySerialExecutor: SerialExecutor {

    // 2. Приватная очередь для последовательного выполнения задач.
    private let queue: DispatchQueue

    init(label: String) {
        self.queue = DispatchQueue(label: label)
    }

    func enqueue(_ job: consuming ExecutorJob) {
        // Создаем Job безопастную для захвата в ссылки.
        let unownedJob = UnownedJob(job)
        // Создаем наш Executor безопасный для захвата в ссылки.
        let unownedExecutor = asUnownedSerialExecutor()
        
        queue.async {
	        // Начинаем синхронное выполенение job на нашей очереди.
            unownedJob.runSynchronously(on: unownedExecutor)
        }
    }

    func asUnownedSerialExecutor() -> UnownedSerialExecutor {
	    // Специальная обертка для создание безхозной ссылки.
        UnownedSerialExecutor(ordinary: self)
    }
}```

После того как мы определили наш свой executor, мы можем его начать использовать в actor. Более подробнее каким образом добавляется executor, в акторы, смотри в разделе [[Actors]].

### Разберемся с протоколом [TaskExecutor](https://developer.apple.com/documentation/swift/taskexecutor)

Начиная с **ios 18**, у Task появилось следующее API

```swift
@discardableResult
Task(
    name: String? = nil,
    executorPreference taskExecutor: (any TaskExecutor)?,
    priority: TaskPriority? = nil,
    operation: sending @escaping () async throws -> Success
)
```
Нас в данном случае интересует поле: "executorPreference taskExecutor: (any TaskExecutor)?" - Оно позволяет нам добавить свой собственный executor, который будет управлять выполнением Job, которые создадуться в этой Task.

Протокол TaskExecutor, повторяет ранее разобранный SerialExecutor
```swift
protocol TaskExecutor : Executor {
	/// Метод в которую прилетает Job, которую нам следует обработать.
    func enqueue(_ job: consuming ExecutorJob)
    /// Возвращает безхозную (unowned) ссылку на executor.
    func asUnownedTaskExecutor() -> UnownedTaskExecutor
}
```

Например, мы хотим, что бы Task которые выполняются на нашем CustomExecutor, выполнялись последовательно, поэтому реализуем следующий класс
```swift
@available(iOS 18.0, *)
final class CustomExecutor: TaskExecutor {
    private let queue: DispatchQueue

    init(label: String) {
        self.queue = DispatchQueue(label: label)
    }

    func enqueue(_ job: consuming ExecutorJob) {
        let unownedJob = UnownedJob(job)
        let unownedExecutor = asUnownedTaskExecutor()

        queue.async {
            unownedJob.runSynchronously(on: unownedExecutor)
        }
    }

    func asUnownedTaskExecutor() -> UnownedTaskExecutor {
        UnownedTaskExecutor(ordinary: self)
    }
}
```

```swift
let customExecutor = CustomExecutor(label: "Test")
// Создаем detached task с предпочтением нашего кастомного исполнителя
Task.detached(executorPreference: customExecutor) {
    print("Работа задачи начинается на потоке: \(Thread.current) 1 ")
    try? await Task.sleep(nanoseconds: 100)
    print("Работа задачи продолжается на потоке: \(Thread.current) 2 ")
}
Task.detached(executorPreference: customExecutor) {
    print("Работа задачи начинается на потоке: \(Thread.current) 3 ")
    try? await Task.sleep(nanoseconds: 100)
    print("Работа задачи продолжается на потоке: \(Thread.current) 4")
}
```
В итоге мы получим следующий ввывод в консоль
```
Работа задачи начинается на потоке: <NSThread: 0x60000170d100> 1 
Работа задачи продолжается на потоке: <NSThread: 0x60000170d100> 2 
Работа задачи начинается на потоке: <NSThread: 0x60000171b180> 3 
Работа задачи продолжается на потоке: <NSThread: 0x600001724040> 4
```
## Job

Это часть таски, набор кода между прерываниями в Task. Если помотреть на открытие методы Job, там можно увидеть слудующее
```swift
/// A unit of schedulable work.
///
/// Unless you're implementing a scheduler,
/// you don't generally interact with jobs directly.
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
@frozen public struct ExecutorJob : Sendable, ~Copyable {

    public init(_ job: UnownedJob)

    public init(_ job: Job)

    public var priority: JobPriority { get }

    public var description: String { get }
}


@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension ExecutorJob {

    /// Run this job on the passed in executor.
    ///
    /// This operation runs the job on the calling thread and *blocks* until the job completes.
    /// The intended use of this method is for an executor to determine when and where it
    /// wants to run the job and then call this method on it.
    ///
    /// The passed in executor reference is used to establish the executor context for the job,
    /// and should be the same executor as the one semantically calling the `runSynchronously` method.
    ///
    /// This operation consumes the job, preventing it accidental use after it has been run.
    ///
    /// Converting a `ExecutorJob` to an ``UnownedJob`` and invoking ``UnownedJob/runSynchronously(_:)` on it multiple times is undefined behavior,
    /// as a job can only ever be run once, and must not be accessed after it has been run.
    ///
    /// - Parameter executor: the executor this job will be semantically running on.
    @inlinable public func runSynchronously(on executor: UnownedSerialExecutor)
    
	...   
}```

Как видно, Job состоит из собственного описания, приоритета и метода для его выполнения.
При выводе description мы получит похожий принт
```swift
ExecutorJob(id: 1)
```
Где id - номер для внутренней индентификации, причем этот id не меняется в пределах Task, неважно сколько было остановок, создается Task -> создается Job (личное наблюдение на тестовом коде)
Далее у нас есть приоритет, тут все понятно, чем выше приоритет, тем выше она будет в очереди на выполнение.
Ну и сам метод вызова выполнение кода `runSynchronously`, этот самый метод и выполняет код между остановками (await) и для его выполнения он ожидает ослабленную ссылку на текущий executor.
## Task

Фундаментальная абстракция для работы со Swift Concurrency. Как понятно из выше описанных буков, Task - не управляет потоком, это "концепция" которая бьется на Job и в дальнейшем планируется на Cooperative Thread Pool

В философии Swift Concurrency существует два "подхода" для работы с асинхронным кодом:
- **Неструктурированная (Unstructured)**
- **Структурированная (Structured)**
#### Неструктурированная (Unstructured)

Это подход (или модель) в котором Task создаются и управляются независимо, без привязки к родительской задаче или зоны видимости. 

Есть 2 способа создать такую задачу:
1. `Task(priority:operation:)` - обычная задача
2. `Task.detached(priority:operation:)` - "изолированная" задача

`Task(priority:operation:)` - задача создается в текущем контексте и наследует почти все, а именно:
- Актор - Если вызвана на MainActor, то и выполняться начнет на MainActor
- Приоритет - наследует приоритет с задачи родителя
- Локальные значения (Task-local values)

`Task.detached(priority:operation:)` - задача создается "вне" контекста и не наследует почти ничего:
- Актор - Не наследуется, запуск всегда с GlobalActor
- Приоритет - не наследует
- Локальные значения (Task-local values) - не получает

К данному подходу следует подходить осторожно, есть ряд проблем которые могут "выстрелить"
- Task Leaks 
- Отсутствие автоматической отмены  
- Сложность отслеживания
#### Структурированная (Structured)

Structured решает проблемы Unstructured и позволяет писать более "чистый" код. 
У данного подхода есть свои ключивые принципы:
- Инкапсуляция и иерархия
- Ожидание завершения
- Сквозная отмена
- Сквозное распространение ошибок

Код при таком подходе выглядит так:
```swift
func loadData() async throws {
    let data1 = try await fetchData()
    let data2 = try await fetchData()
    let data3 = try await fetchData()
    print("Finished loading: \(data1), \(data2), \(data3)")
}
```

#### Task-local values
**Task-local values** - они же локальные значения задач, это значения которые привязаны к определенной задаче и передается к дочерним задачам при Structured (исключение detached), являются static свойствами.
Примером такой task-local values - `Task.isCancelled`. Хоть данное свойство является статической переменной, но позволяет узнать статус отмены **текущей** задачи.
В случае крайней необходимости мы можем создать свои собственные Task-local value, для этого нужно проделать следующее:
1. Создать static свойство в обертке (enum, struct, class и т.п)
2. На этом свойстве использовать @TaskLocal
3. Создать задачу предварительно и обернуть код из таски в `await YourBox.$taskLocal.withValue(_)`
Базовый пример:
```swift
enum CustomTaskLocalValue {
    @TaskLocal
    static var localId: String?
}

Task {
    try await CustomTaskLocalValue.$localId.withValue("Task1") {
        print("Start \(CustomTaskLocalValue.localId)")
        try await Task.sleep(for: .seconds(1))
        print("End \(CustomTaskLocalValue.localId)")
    }
}

Вывод в консоль:
Start Optional("Task1")
End Optional("Task1")
```
А теперь предлагаю натянуть этот пример с учетом подходов SC и посмотреть как будут передавать task-local values при Unstructured/Structured, основа когда будет такая же как выше, для сокращения повторяющийся код буду заменять `...`
**Structured**

```swift
...

Task {
    try await CustomTaskLocalValue.$localId.withValue("Task1") {
        print("Start \(CustomTaskLocalValue.localId)")
        await test()
        print("End \(CustomTaskLocalValue.localId)")
    }
}

func test() async {
    print("Start in test \(CustomTaskLocalValue.localId)")
    try await Task.sleep(for: .seconds(0.1))
	print("End in test \(CustomTaskLocalValue.localId)")
}
___
Вывод в консоль:
Start Optional("Task1")
Start in test Optional("Task1")
End in test Optional("Task1")
End Optional("Task1")
```
Как видно из вывода в консоли, task-local value передались дальше по иерархии, теперь рассмотрим случай из Unstructured с созданием Task 
```swift
...

Task {
    try await CustomTaskLocalValue.$localId.withValue("Task1") {
        print("Start \(CustomTaskLocalValue.localId)")
        Task {
	        await test()
        }
        print("End \(CustomTaskLocalValue.localId)")
    }
}

...
___
Вывод в консоль:
Start Optional("Task1")
Start in test Optional("Task1")
End Optional("Task1")
End in test Optional("Task1")
```
Вывод в консоле изменился в последовательности, но само значение task-local value осталось не изменным -> они передаются дальше, а теперь расмотрим последний вариант. с Unstructured но с созданием `Task.detached`
```swift
...

Task {
    try await CustomTaskLocalValue.$localId.withValue("Task1") {
        print("Start \(CustomTaskLocalValue.localId)")
        Task.detached {
	        await test()
        }
        print("End \(CustomTaskLocalValue.localId)")
    }
}

...
___
Вывод в консоль:
Start Optional("Task1")
Start in test nil
End Optional("Task1")
End in test nil
```
Как видим, тут у нас task-local value возвращает как nil из за особенности создания Task.detached которая создает задачу в отрыве от контекста предыдущей.

Task-local value - вы вряд ли будете использовать для повседневного кода, т.к оно не предназначена для передачи **обычных** параметром, но полезно помнить о такой возможности. Их следует применять когда следует передать сквозную информацию, ну например предать уровень логирования вглубь иерархии.

Особенности:
- Не является заменой параметров, и не предназначен для основных данных.
- Только для чтения. 



--
https://wwdcnotes.com/documentation/wwdcnotes/wwdc21-10254-swift-concurrency-behind-the-scenes/
https://habr.com/ru/articles/887240/
https://habr.com/ru/companies/otus/articles/588540/
https://colinchswift.github.io/2023-09-18/10-48-35-840309-best-practices-for-thread-pool-management-in-swift-multithreading/
https://jackmorris.xyz/posts/2023/11/21/controlling-actors-with-custom-executors/
https://habr.com/ru/companies/cleverpumpkin/articles/790782/